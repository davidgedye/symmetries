<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montage</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            padding: 12px 20px;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        h1 {
            font-size: 18px;
            font-weight: 500;
        }

        .toolbar {
            display: flex;
            gap: 8px;
        }

        button {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #4a4a4a;
        }

        .zoom-info {
            margin-left: auto;
            font-size: 14px;
            color: #888;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas-container {
            position: absolute;
            inset: 0;
        }

        #drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }

        #drop-zone.active {
            background: rgba(66, 133, 244, 0.1);
            border: 2px dashed #4285f4;
        }

        #drop-zone.empty {
            pointer-events: auto;
        }

        .drop-hint {
            text-align: center;
            color: #666;
        }

        .drop-hint p {
            margin: 8px 0;
        }

        .drop-hint .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .heic-loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px 32px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 1000;
        }

        #file-input {
            display: none;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 12px;
            color: #888;
            line-height: 1.6;
            z-index: 100;
        }

        .context-menu {
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-menu-item:hover {
            background: #3a3a3a;
        }

        .context-menu-item .shortcut {
            color: #666;
            font-size: 12px;
            margin-left: 16px;
        }

        .context-menu-separator {
            height: 1px;
            background: #4a4a4a;
            margin: 4px 0;
        }

        .context-menu-label {
            padding: 6px 16px;
            font-size: 12px;
            color: #888;
            display: flex;
            justify-content: space-between;
        }

        .context-menu-item.blend-option {
            padding-left: 24px;
            font-size: 13px;
        }

        .context-menu-item.blend-option.active {
            color: #4285f4;
        }

        .context-menu-item.blend-option.active::before {
            content: 'âœ“';
            position: absolute;
            left: 8px;
        }

        .context-menu-item.blend-option {
            position: relative;
        }

        .progress-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 24px 32px;
            border-radius: 8px;
            z-index: 1000;
            min-width: 300px;
            text-align: center;
        }

        .progress-modal h3 {
            margin: 0 0 16px 0;
            font-size: 16px;
            font-weight: 500;
        }

        .progress-bar-container {
            background: #3a3a3a;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .progress-bar {
            background: #4285f4;
            height: 100%;
            width: 0%;
            transition: width 0.2s ease;
        }

        .progress-text {
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <header>
        <h1>Montage</h1>
        <div class="toolbar">
            <button id="add-btn">Add Image</button>
            <button id="save-btn" title="Export JPG (S)">â¬‡ Export</button>
            <button id="save-project-btn" title="Save Project (Ctrl+S)">ðŸ’¾ Save Project</button>
            <button id="flip-h-btn" title="Flip Horizontal (H)">â†” Flip H</button>
            <button id="flip-v-btn" title="Flip Vertical (V)">â†• Flip V</button>
            <button id="rotate-l-btn" title="Rotate Left (L)">&circlearrowleft; Rot L</button>
            <button id="rotate-r-btn" title="Rotate Right (R)">&circlearrowright; Rot R</button>
            <button id="duplicate-btn" title="Duplicate (D)">â§‰ Duplicate</button>
            <button id="totop-btn" title="Bring to Top (T)">â¬† To Top</button>
            <button id="tobottom-btn" title="Send to Bottom (G)">â¬‡ To Bottom</button>
            <button id="reset-view-btn">Reset View</button>
        </div>
        <div class="zoom-info">
            Zoom: <span id="zoom-level">100%</span>
        </div>
    </header>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
        <div id="drop-zone" class="empty">
            <div class="drop-hint">
                <div class="icon">+</div>
                <p>Drop images or .montage files here</p>
                <p>or click Add Image</p>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept="image/*,.heic,.heif,.montage" multiple>

    <div class="instructions">
        Scroll to zoom | Drag canvas to pan | Click image to select | Drag corners to resize<br>
        H/V: flip | L/R: rotate | D: duplicate | T/G: top/bottom | B: blend | S: export | Ctrl+S: save project | Del: remove
    </div>

    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic-to@1/dist/iife/heic-to.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3/dist/jszip.min.js"></script>
    <script>
        const wrapper = document.getElementById('canvas-wrapper');
        const container = document.getElementById('canvas-container');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const addBtn = document.getElementById('add-btn');
        const resetViewBtn = document.getElementById('reset-view-btn');
        const zoomLevelSpan = document.getElementById('zoom-level');

        // Initialize Konva stage
        const stage = new Konva.Stage({
            container: 'canvas-container',
            width: wrapper.clientWidth,
            height: wrapper.clientHeight,
            draggable: true
        });

        // Layer for images
        const imageLayer = new Konva.Layer();
        stage.add(imageLayer);

        // Transformer for selected images
        const transformer = new Konva.Transformer({
            keepRatio: true,
            enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
            rotateEnabled: false, // Disable free rotation; use L/R keys for 90Â° increments
            boundBoxFunc: (oldBox, newBox) => {
                // Minimum size constraint
                if (newBox.width < 20 || newBox.height < 20) {
                    return oldBox;
                }
                return newBox;
            }
        });
        imageLayer.add(transformer);

        let imageCount = 0;

        // Load image onto canvas
        function addImage(src, fileName) {
            const img = new Image();
            img.onload = () => {
                // Scale down if larger than viewport
                let scale = 1;
                const maxDim = Math.min(stage.width(), stage.height()) * 0.6;
                if (img.width > maxDim || img.height > maxDim) {
                    scale = maxDim / Math.max(img.width, img.height);
                }

                // Calculate viewport center in stage coordinates
                const viewportCenterX = (stage.width() / 2 - stage.x()) / stage.scaleX();
                const viewportCenterY = (stage.height() / 2 - stage.y()) / stage.scaleY();

                const konvaImage = new Konva.Image({
                    image: img,
                    x: viewportCenterX + imageCount * 30,
                    y: viewportCenterY + imageCount * 30,
                    scaleX: scale,
                    scaleY: scale,
                    offsetX: img.width / 2,
                    offsetY: img.height / 2,
                    draggable: true,
                    name: fileName || `image-${imageCount}`
                });

                // Store original image data for full-res export later
                konvaImage.setAttr('originalImage', img);
                konvaImage.setAttr('originalWidth', img.width);
                konvaImage.setAttr('originalHeight', img.height);

                // Initialize crop bounds (non-destructive)
                konvaImage.setAttr('cropBounds', { top: 0, right: 0, bottom: 0, left: 0 });

                // Initialize blend mode
                konvaImage.setAttr('blendMode', 'source-over');

                // Click to select
                konvaImage.on('click tap', (e) => {
                    e.cancelBubble = true;
                    transformer.nodes([konvaImage]);
                    updateCropHandles();
                    imageLayer.batchDraw();
                });

                // Double click to bring to front
                konvaImage.on('dblclick dbltap', () => {
                    konvaImage.moveToTop();
                    transformer.moveToTop();
                    updateCropHandles();
                    imageLayer.batchDraw();
                });

                // Right click for context menu
                konvaImage.on('contextmenu', (e) => {
                    e.evt.preventDefault();
                    e.cancelBubble = true;
                    transformer.nodes([konvaImage]);
                    updateCropHandles();
                    showContextMenu(e.evt.clientX, e.evt.clientY, konvaImage);
                    imageLayer.batchDraw();
                });

                // Update crop handles when image is dragged
                konvaImage.on('dragmove', () => {
                    updateCropHandles();
                });

                imageLayer.add(konvaImage);
                transformer.nodes([konvaImage]);
                transformer.moveToTop();
                updateCropHandles();
                imageLayer.batchDraw();

                imageCount++;
                updateDropZoneVisibility();
            };
            img.src = src;
        }

        // Check if file is HEIC/HEIF
        function isHeicFile(file) {
            const name = file.name.toLowerCase();
            return name.endsWith('.heic') || name.endsWith('.heif') ||
                   file.type === 'image/heic' || file.type === 'image/heif';
        }

        // Convert HEIC to PNG data URL using heic-to
        async function convertHeicToDataUrl(file) {
            const convertedBlob = await HeicTo({
                blob: file,
                type: 'image/png',
                quality: 1
            });

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(convertedBlob);
            });
        }

        // Show/hide HEIC loading message
        function showHeicLoading(fileName) {
            let el = document.querySelector('.heic-loading');
            if (!el) {
                el = document.createElement('div');
                el.className = 'heic-loading';
                document.body.appendChild(el);
            }
            el.textContent = `Converting from HEIC: ${fileName}...`;
            el.style.display = 'block';
        }

        function hideHeicLoading() {
            const el = document.querySelector('.heic-loading');
            if (el) el.style.display = 'none';
        }

        // Handle file selection
        async function handleFiles(files) {
            for (const file of Array.from(files)) {
                try {
                    if (isMontageFile(file)) {
                        // Load project file
                        await loadProject(file);
                    } else if (isHeicFile(file)) {
                        // Show loading message and convert HEIC to data URL
                        showHeicLoading(file.name);
                        const dataUrl = await convertHeicToDataUrl(file);
                        hideHeicLoading();
                        addImage(dataUrl, file.name.replace(/\.heic$/i, '.png').replace(/\.heif$/i, '.png'));
                    } else if (file.type.startsWith('image/') || file.type === '') {
                        // Regular image or unknown type (try loading it)
                        const reader = new FileReader();
                        reader.onload = (e) => addImage(e.target.result, file.name);
                        reader.readAsDataURL(file);
                    }
                } catch (err) {
                    hideHeicLoading();
                    console.error('Error loading file:', file.name, err);
                    alert(`Could not load ${file.name}: ${err.message}`);
                }
            }
        }

        // Check if file is a .montage project file
        function isMontageFile(file) {
            return file.name.toLowerCase().endsWith('.montage');
        }

        // Update drop zone visibility
        function updateDropZoneVisibility() {
            const hasImages = imageLayer.children.length > 1; // transformer is always there
            dropZone.classList.toggle('empty', !hasImages);
            dropZone.querySelector('.drop-hint').style.display = hasImages ? 'none' : 'block';
        }

        // Deselect when clicking on empty area
        stage.on('click tap', (e) => {
            if (e.target === stage) {
                transformer.nodes([]);
                removeCropHandles();
                imageLayer.batchDraw();
            }
        });

        // Zoom with scroll wheel
        stage.on('wheel', (e) => {
            e.evt.preventDefault();

            const oldScale = stage.scaleX();
            const pointer = stage.getPointerPosition();

            const mousePointTo = {
                x: (pointer.x - stage.x()) / oldScale,
                y: (pointer.y - stage.y()) / oldScale
            };

            const direction = e.evt.deltaY > 0 ? -1 : 1;
            const scaleBy = 1.1;
            let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;

            // Clamp zoom level
            newScale = Math.max(0.1, Math.min(10, newScale));

            stage.scale({ x: newScale, y: newScale });

            const newPos = {
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale
            };
            stage.position(newPos);
            updateCropHandles();
            stage.batchDraw();

            zoomLevelSpan.textContent = Math.round(newScale * 100) + '%';
        });

        // Update crop handles when stage is dragged
        stage.on('dragmove', () => {
            updateCropHandles();
        });

        // Reset view
        resetViewBtn.addEventListener('click', () => {
            stage.scale({ x: 1, y: 1 });
            stage.position({ x: 0, y: 0 });
            updateCropHandles();
            stage.batchDraw();
            zoomLevelSpan.textContent = '100%';
        });

        // File input handling
        addBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        // Flip and rotate functions
        function flipHorizontal() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.scaleX(node.scaleX() * -1);
            updateCropHandles();
            imageLayer.batchDraw();
        }

        function flipVertical() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.scaleY(node.scaleY() * -1);
            updateCropHandles();
            imageLayer.batchDraw();
        }

        function rotateLeft() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.rotation(node.rotation() - 90);
            updateCropHandles();
            imageLayer.batchDraw();
        }

        function rotateRight() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.rotation(node.rotation() + 90);
            updateCropHandles();
            imageLayer.batchDraw();
        }

        function duplicateImage() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];

            const clone = node.clone({
                x: node.x() + 30,
                y: node.y() + 30
            });

            // Copy stored original image data
            clone.setAttr('originalImage', node.getAttr('originalImage'));
            clone.setAttr('originalWidth', node.getAttr('originalWidth'));
            clone.setAttr('originalHeight', node.getAttr('originalHeight'));
            clone.setAttr('cropBounds', { ...node.getAttr('cropBounds') });
            clone.setAttr('blendMode', node.getAttr('blendMode'));
            clone.globalCompositeOperation(node.getAttr('blendMode') || 'source-over');

            // Set up event handlers for the clone
            clone.on('click tap', (e) => {
                e.cancelBubble = true;
                transformer.nodes([clone]);
                updateCropHandles();
                imageLayer.batchDraw();
            });

            clone.on('dblclick dbltap', () => {
                clone.moveToTop();
                transformer.moveToTop();
                updateCropHandles();
                imageLayer.batchDraw();
            });

            clone.on('contextmenu', (e) => {
                e.evt.preventDefault();
                e.cancelBubble = true;
                transformer.nodes([clone]);
                updateCropHandles();
                showContextMenu(e.evt.clientX, e.evt.clientY, clone);
                imageLayer.batchDraw();
            });

            clone.on('dragmove', () => {
                updateCropHandles();
            });

            imageLayer.add(clone);
            transformer.nodes([clone]);
            transformer.moveToTop();
            updateCropHandles();
            imageLayer.batchDraw();
            imageCount++;
        }

        // Flip/rotate button handlers
        document.getElementById('flip-h-btn').addEventListener('click', flipHorizontal);
        document.getElementById('flip-v-btn').addEventListener('click', flipVertical);
        document.getElementById('rotate-l-btn').addEventListener('click', rotateLeft);
        document.getElementById('rotate-r-btn').addEventListener('click', rotateRight);
        document.getElementById('duplicate-btn').addEventListener('click', duplicateImage);

        // Bring to top functionality
        function bringToTop() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.moveToTop();
            transformer.moveToTop();
            updateCropHandles();
            imageLayer.batchDraw();
        }

        // Send to bottom functionality
        function sendToBottom() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.moveToBottom();
            transformer.moveToTop();
            updateCropHandles();
            imageLayer.batchDraw();
        }

        document.getElementById('totop-btn').addEventListener('click', bringToTop);
        document.getElementById('tobottom-btn').addEventListener('click', sendToBottom);

        // Blend modes for double-exposure effects
        const blendModes = [
            { value: 'source-over', label: 'Normal' },
            { value: 'screen', label: 'Screen' },
            { value: 'multiply', label: 'Multiply' },
            { value: 'lighten', label: 'Lighten' },
            { value: 'darken', label: 'Darken' },
            { value: 'overlay', label: 'Overlay' },
            { value: 'soft-light', label: 'Soft Light' },
            { value: 'difference', label: 'Difference' }
        ];

        function setBlendMode(mode) {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            node.setAttr('blendMode', mode);
            node.globalCompositeOperation(mode);
            imageLayer.batchDraw();
        }

        function cycleBlendMode() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];
            const currentMode = node.getAttr('blendMode') || 'source-over';
            const currentIndex = blendModes.findIndex(m => m.value === currentMode);
            const nextIndex = (currentIndex + 1) % blendModes.length;
            const nextMode = blendModes[nextIndex];
            setBlendMode(nextMode.value);
            // Brief visual feedback - could add a toast here
            console.log('Blend mode:', nextMode.label);
        }

        // Crop handles management
        let cropHandles = [];
        const HANDLE_SIZE = 12;
        const HANDLE_COLOR = '#4285f4';
        const HANDLE_STROKE = '#fff';

        function createCropHandles(node) {
            removeCropHandles();

            // Store the node's _id for verification
            const nodeId = node._id;

            const handles = ['top', 'right', 'bottom', 'left'];
            handles.forEach(position => {
                const handle = new Konva.Rect({
                    width: position === 'top' || position === 'bottom' ? HANDLE_SIZE * 2 : HANDLE_SIZE,
                    height: position === 'left' || position === 'right' ? HANDLE_SIZE * 2 : HANDLE_SIZE,
                    fill: HANDLE_COLOR,
                    stroke: HANDLE_STROKE,
                    strokeWidth: 1,
                    cornerRadius: 2,
                    draggable: true,
                    name: `crop-handle-${position}`
                });

                handle.setAttr('handlePosition', position);
                handle.setAttr('targetNodeId', nodeId);

                // Set cursor based on handle position
                const cursors = { top: 'ns-resize', bottom: 'ns-resize', left: 'ew-resize', right: 'ew-resize' };
                handle.on('mouseenter', () => { stage.container().style.cursor = cursors[position]; });
                handle.on('mouseleave', () => { stage.container().style.cursor = 'default'; });

                // Prevent clicks on handles from affecting selection
                handle.on('click tap', (e) => {
                    e.cancelBubble = true;
                });

                handle.on('mousedown touchstart', (e) => {
                    e.cancelBubble = true;
                });

                // Handle drag for cropping
                handle.on('dragmove', (e) => {
                    e.cancelBubble = true;
                    // Verify we're still operating on the correct node
                    const selectedNodes = transformer.nodes();
                    if (selectedNodes.length === 0) return;
                    const currentNode = selectedNodes[0];
                    if (currentNode._id !== nodeId) return;

                    updateCropFromHandle(currentNode, handle, position);
                });

                handle.on('dragend', (e) => {
                    e.cancelBubble = true;
                    const selectedNodes = transformer.nodes();
                    if (selectedNodes.length === 0) return;
                    const currentNode = selectedNodes[0];
                    if (currentNode._id !== nodeId) return;

                    positionCropHandles(currentNode);
                });

                imageLayer.add(handle);
                cropHandles.push(handle);
            });

            positionCropHandles(node);
        }

        // Track which node the crop handles were created for
        let cropHandlesNodeId = null;

        function removeCropHandles() {
            cropHandles.forEach(handle => handle.destroy());
            cropHandles = [];
            cropHandlesNodeId = null;
        }

        function positionCropHandles(node) {
            if (cropHandles.length === 0) return;

            // Get the node's bounding rectangle in stage coordinates (not screen)
            const rect = node.getClientRect({ relativeTo: stage });
            const stagePos = stage.position();
            const stageScale = stage.scaleX();

            cropHandles.forEach(handle => {
                const pos = handle.getAttr('handlePosition');
                let x, y;

                // Position handles at edge midpoints (in stage coordinates)
                switch (pos) {
                    case 'top':
                        x = rect.x + rect.width / 2 - (HANDLE_SIZE * 2) / 2;
                        y = rect.y - HANDLE_SIZE / 2;
                        break;
                    case 'bottom':
                        x = rect.x + rect.width / 2 - (HANDLE_SIZE * 2) / 2;
                        y = rect.y + rect.height - HANDLE_SIZE / 2;
                        break;
                    case 'left':
                        x = rect.x - HANDLE_SIZE / 2;
                        y = rect.y + rect.height / 2 - (HANDLE_SIZE * 2) / 2;
                        break;
                    case 'right':
                        x = rect.x + rect.width - HANDLE_SIZE / 2;
                        y = rect.y + rect.height / 2 - (HANDLE_SIZE * 2) / 2;
                        break;
                }

                handle.position({ x, y });
            });

            // Keep handles on top
            cropHandles.forEach(h => h.moveToTop());
        }

        // Map visual handle position to source image edge, accounting for rotation and flip
        function getSourceEdge(visualHandle, rotation, scaleX, scaleY) {
            // Normalize rotation to 0, 90, 180, 270
            let rot = ((rotation % 360) + 360) % 360;
            rot = Math.round(rot / 90) * 90 % 360;

            // Rotation mapping: visual -> source (before flip adjustment)
            const rotationMaps = {
                0:   { top: 'top', right: 'right', bottom: 'bottom', left: 'left' },
                90:  { top: 'left', right: 'top', bottom: 'right', left: 'bottom' },
                180: { top: 'bottom', right: 'left', bottom: 'top', left: 'right' },
                270: { top: 'right', right: 'bottom', bottom: 'left', left: 'top' }
            };

            let sourceEdge = rotationMaps[rot][visualHandle];

            // Apply flip: if flipped, swap the corresponding edges
            if (scaleX < 0) {
                if (sourceEdge === 'left') sourceEdge = 'right';
                else if (sourceEdge === 'right') sourceEdge = 'left';
            }
            if (scaleY < 0) {
                if (sourceEdge === 'top') sourceEdge = 'bottom';
                else if (sourceEdge === 'bottom') sourceEdge = 'top';
            }

            return sourceEdge;
        }

        function updateCropFromHandle(node, handle, visualPosition) {
            // Validate node exists and has required attributes
            if (!node || node.isDestroyed || !node.getAttr('originalWidth')) return;

            const originalWidth = node.getAttr('originalWidth');
            const originalHeight = node.getAttr('originalHeight');
            const currentCrop = node.getAttr('cropBounds') || { top: 0, right: 0, bottom: 0, left: 0 };

            // Get the node's bounding rectangle in stage coordinates
            const rect = node.getClientRect({ relativeTo: stage });
            const handlePos = handle.position();
            const scaleX = node.scaleX();
            const scaleY = node.scaleY();
            const absScaleX = Math.abs(scaleX);
            const absScaleY = Math.abs(scaleY);
            const rotation = node.rotation();

            // Map visual handle to source edge
            const sourceEdge = getSourceEdge(visualPosition, rotation, scaleX, scaleY);

            // Calculate visual delta (how far handle moved from edge)
            let visualDelta;
            switch (visualPosition) {
                case 'top':
                    visualDelta = handlePos.y + HANDLE_SIZE / 2 - rect.y;
                    break;
                case 'bottom':
                    visualDelta = rect.y + rect.height - handlePos.y - HANDLE_SIZE / 2;
                    break;
                case 'left':
                    visualDelta = handlePos.x + HANDLE_SIZE / 2 - rect.x;
                    break;
                case 'right':
                    visualDelta = rect.x + rect.width - handlePos.x - HANDLE_SIZE / 2;
                    break;
            }

            // Convert visual delta to source coordinates
            // For horizontal visual movement -> use absScaleX, for vertical -> use absScaleY
            const isVisualHorizontal = (visualPosition === 'left' || visualPosition === 'right');
            const scale = isVisualHorizontal ? absScaleX : absScaleY;
            const sourceDelta = visualDelta / scale;

            // Apply to the correct source edge
            let newCrop = { ...currentCrop };
            const minSize = 20;

            switch (sourceEdge) {
                case 'top':
                    newCrop.top = Math.max(0, Math.min(originalHeight - currentCrop.bottom - minSize, currentCrop.top + sourceDelta));
                    break;
                case 'bottom':
                    newCrop.bottom = Math.max(0, Math.min(originalHeight - currentCrop.top - minSize, currentCrop.bottom + sourceDelta));
                    break;
                case 'left':
                    newCrop.left = Math.max(0, Math.min(originalWidth - currentCrop.right - minSize, currentCrop.left + sourceDelta));
                    break;
                case 'right':
                    newCrop.right = Math.max(0, Math.min(originalWidth - currentCrop.left - minSize, currentCrop.right + sourceDelta));
                    break;
            }

            // Pass both visual position (for handle repositioning) and source edge (for position anchoring)
            applyCropBounds(node, newCrop, sourceEdge);
        }

        function applyCropBounds(node, cropBounds, sourceEdgeBeingCropped) {
            // Validate node
            if (!node || node.isDestroyed) return;

            const originalWidth = node.getAttr('originalWidth');
            const originalHeight = node.getAttr('originalHeight');

            // Validate we have original dimensions
            if (!originalWidth || !originalHeight) return;

            const cropX = cropBounds.left;
            const cropY = cropBounds.top;
            const cropWidth = originalWidth - cropBounds.left - cropBounds.right;
            const cropHeight = originalHeight - cropBounds.top - cropBounds.bottom;

            // Validate crop dimensions are positive
            if (cropWidth <= 0 || cropHeight <= 0) return;

            // Determine which source edge to anchor (opposite of the one being cropped)
            const anchorSourceEdge = {
                'left': 'right',
                'right': 'left',
                'top': 'bottom',
                'bottom': 'top'
            }[sourceEdgeBeingCropped];

            // Get visual bounding box BEFORE applying crop
            const rectBefore = node.getClientRect({ relativeTo: stage });

            // Store the crop bounds
            node.setAttr('cropBounds', cropBounds);

            // Apply the Konva crop
            node.crop({ x: cropX, y: cropY, width: cropWidth, height: cropHeight });
            node.width(cropWidth);
            node.height(cropHeight);
            node.offsetX(cropWidth / 2);
            node.offsetY(cropHeight / 2);

            // Get visual bounding box AFTER applying crop
            const rectAfter = node.getClientRect({ relativeTo: stage });

            // Adjust position to keep the anchor edge visually fixed
            if (anchorSourceEdge) {
                // Map the anchor SOURCE edge to VISUAL edge position
                const rotation = node.rotation();
                const scaleX = node.scaleX();
                const scaleY = node.scaleY();

                // Reverse mapping: source edge -> visual edge
                // Konva applies transforms as: scale (flip) then rotate
                // So to map source -> visual: apply flip first, then rotation
                let rot = ((rotation % 360) + 360) % 360;
                rot = Math.round(rot / 90) * 90 % 360;

                // First apply flip (source -> flipped)
                let flippedEdge = anchorSourceEdge;
                if (scaleX < 0) {
                    if (flippedEdge === 'left') flippedEdge = 'right';
                    else if (flippedEdge === 'right') flippedEdge = 'left';
                }
                if (scaleY < 0) {
                    if (flippedEdge === 'top') flippedEdge = 'bottom';
                    else if (flippedEdge === 'bottom') flippedEdge = 'top';
                }

                // Then apply rotation (flipped -> visual)
                const visualMaps = {
                    0:   { top: 'top', right: 'right', bottom: 'bottom', left: 'left' },
                    90:  { top: 'right', right: 'bottom', bottom: 'left', left: 'top' },
                    180: { top: 'bottom', right: 'left', bottom: 'top', left: 'right' },
                    270: { top: 'left', right: 'top', bottom: 'right', left: 'bottom' }
                };

                let visualAnchor = visualMaps[rot][flippedEdge];

                // Calculate how much to adjust based on visual anchor edge
                let dx = 0, dy = 0;
                switch (visualAnchor) {
                    case 'left':
                        dx = rectBefore.x - rectAfter.x;
                        break;
                    case 'right':
                        dx = (rectBefore.x + rectBefore.width) - (rectAfter.x + rectAfter.width);
                        break;
                    case 'top':
                        dy = rectBefore.y - rectAfter.y;
                        break;
                    case 'bottom':
                        dy = (rectBefore.y + rectBefore.height) - (rectAfter.y + rectAfter.height);
                        break;
                }

                node.x(node.x() + dx);
                node.y(node.y() + dy);
            }

            imageLayer.batchDraw();
        }

        function resetCrop() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) return;
            const node = nodes[0];

            const originalWidth = node.getAttr('originalWidth');
            const originalHeight = node.getAttr('originalHeight');

            node.setAttr('cropBounds', { top: 0, right: 0, bottom: 0, left: 0 });
            node.crop({ x: 0, y: 0, width: originalWidth, height: originalHeight });
            node.width(originalWidth);
            node.height(originalHeight);
            node.offsetX(originalWidth / 2);
            node.offsetY(originalHeight / 2);

            positionCropHandles(node);
            imageLayer.batchDraw();
        }

        function updateCropHandles() {
            const nodes = transformer.nodes();
            if (nodes.length === 0) {
                removeCropHandles();
                cropHandlesNodeId = null;
                return;
            }
            const node = nodes[0];

            // Recreate handles if node changed, otherwise just reposition
            if (cropHandlesNodeId !== node._id) {
                createCropHandles(node);
                cropHandlesNodeId = node._id;
            } else {
                positionCropHandles(node);
            }
        }

        // Update crop handles when transformer changes
        transformer.on('transform', updateCropHandles);
        transformer.on('transformend', updateCropHandles);

        // Context menu
        let contextMenu = null;

        function showContextMenu(x, y, node) {
            hideContextMenu();

            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';

            const currentBlend = node.getAttr('blendMode') || 'source-over';
            const blendMenuItems = blendModes.map(m =>
                `<div class="context-menu-item blend-option${m.value === currentBlend ? ' active' : ''}" data-action="blend" data-blend="${m.value}">${m.label}</div>`
            ).join('');

            contextMenu.innerHTML = `
                <div class="context-menu-item" data-action="totop">Bring to Top <span class="shortcut">T</span></div>
                <div class="context-menu-item" data-action="tobottom">Send to Bottom <span class="shortcut">G</span></div>
                <div class="context-menu-item" data-action="duplicate">Duplicate <span class="shortcut">D</span></div>
                <div class="context-menu-item" data-action="fliph">Flip Horizontal <span class="shortcut">H</span></div>
                <div class="context-menu-item" data-action="flipv">Flip Vertical <span class="shortcut">V</span></div>
                <div class="context-menu-item" data-action="resetcrop">Reset Crop</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-label">Blend Mode <span class="shortcut">B</span></div>
                ${blendMenuItems}
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="delete">Delete <span class="shortcut">Del</span></div>
            `;
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';

            contextMenu.addEventListener('click', (e) => {
                const item = e.target.closest('.context-menu-item');
                if (!item) return;

                const action = item.dataset.action;
                // Make sure the node is selected
                transformer.nodes([node]);

                switch (action) {
                    case 'totop': bringToTop(); break;
                    case 'tobottom': sendToBottom(); break;
                    case 'duplicate': duplicateImage(); break;
                    case 'fliph': flipHorizontal(); break;
                    case 'flipv': flipVertical(); break;
                    case 'resetcrop': resetCrop(); break;
                    case 'blend':
                        const blendValue = item.dataset.blend;
                        setBlendMode(blendValue);
                        break;
                    case 'delete':
                        node.destroy();
                        transformer.nodes([]);
                        removeCropHandles();
                        updateDropZoneVisibility();
                        break;
                }

                hideContextMenu();
                imageLayer.batchDraw();
            });

            document.body.appendChild(contextMenu);

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }

        // Prevent default context menu on canvas
        container.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Export functionality
        function exportCanvas() {
            // Get all images (exclude transformer)
            const images = imageLayer.children.filter(child => child instanceof Konva.Image);
            if (images.length === 0) {
                alert('No images to export');
                return;
            }

            // Calculate bounding box of all images in screen coordinates
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            images.forEach(img => {
                const rect = img.getClientRect();
                minX = Math.min(minX, rect.x);
                minY = Math.min(minY, rect.y);
                maxX = Math.max(maxX, rect.x + rect.width);
                maxY = Math.max(maxY, rect.y + rect.height);
            });

            // Export at 2x screen resolution for good quality
            const exportScale = 2;
            const exportWidth = Math.round((maxX - minX) * exportScale);
            const exportHeight = Math.round((maxY - minY) * exportScale);

            // Create offscreen canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth;
            exportCanvas.height = exportHeight;
            const ctx = exportCanvas.getContext('2d');

            // Fill with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportWidth, exportHeight);

            // Sort images by z-index
            const sortedImages = [...images].sort((a, b) => a.zIndex() - b.zIndex());

            // Get current stage zoom for coordinate conversion
            const stageZoom = stage.scaleX();

            // Draw each image
            sortedImages.forEach(img => {
                const originalImg = img.getAttr('originalImage') || img.image();
                const crop = img.crop();
                const scaleX = img.scaleX();
                const scaleY = img.scaleY();
                const absScaleX = Math.abs(scaleX);
                const absScaleY = Math.abs(scaleY);
                const rotation = img.rotation();
                const blendMode = img.getAttr('blendMode') || 'source-over';

                // Get crop dimensions (the source rectangle from the original image)
                const cropX = crop.x || 0;
                const cropY = crop.y || 0;
                const cropW = crop.width || originalImg.width;
                const cropH = crop.height || originalImg.height;

                // Get the bounding box center in screen coordinates
                const imgRect = img.getClientRect();
                const centerX = imgRect.x + imgRect.width / 2;
                const centerY = imgRect.y + imgRect.height / 2;
                const exportX = (centerX - minX) * exportScale;
                const exportY = (centerY - minY) * exportScale;

                // Displayed size = crop size * image scale * stage zoom * export scale
                const drawWidth = cropW * absScaleX * stageZoom * exportScale;
                const drawHeight = cropH * absScaleY * stageZoom * exportScale;

                ctx.save();
                ctx.globalCompositeOperation = blendMode;
                ctx.translate(exportX, exportY);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.scale(scaleX < 0 ? -1 : 1, scaleY < 0 ? -1 : 1);

                // Draw the image
                ctx.drawImage(
                    originalImg,
                    cropX, cropY, cropW, cropH,
                    -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight
                );

                ctx.restore();
            });

            // Download
            const link = document.createElement('a');
            link.download = 'montage-export.jpg';
            link.href = exportCanvas.toDataURL('image/jpeg', 0.92);
            link.click();
        }

        document.getElementById('save-btn').addEventListener('click', exportCanvas);

        // Progress modal functions
        let progressModal = null;

        function showProgressModal(title) {
            hideProgressModal();
            progressModal = document.createElement('div');
            progressModal.className = 'progress-modal';
            progressModal.innerHTML = `
                <h3>${title}</h3>
                <div class="progress-bar-container">
                    <div class="progress-bar"></div>
                </div>
                <div class="progress-text">Preparing...</div>
            `;
            document.body.appendChild(progressModal);
        }

        function updateProgress(percent, text) {
            if (!progressModal) return;
            const bar = progressModal.querySelector('.progress-bar');
            const textEl = progressModal.querySelector('.progress-text');
            if (bar) bar.style.width = percent + '%';
            if (textEl) textEl.textContent = text;
        }

        function hideProgressModal() {
            if (progressModal) {
                progressModal.remove();
                progressModal = null;
            }
        }

        // Save project as .montage file
        async function saveProject() {
            const images = imageLayer.children.filter(child => child instanceof Konva.Image);
            if (images.length === 0) {
                alert('No images to save');
                return;
            }

            showProgressModal('Saving Project...');

            try {
                const zip = new JSZip();
                const imgFolder = zip.folder('images');
                const projectData = {
                    version: 1,
                    stagePosition: { x: stage.x(), y: stage.y() },
                    stageScale: stage.scaleX(),
                    images: []
                };

                // Sort images by z-index to preserve layer order
                const sortedImages = [...images].sort((a, b) => a.zIndex() - b.zIndex());

                for (let i = 0; i < sortedImages.length; i++) {
                    const img = sortedImages[i];
                    const originalImg = img.getAttr('originalImage') || img.image();
                    const filename = `${i}.png`;

                    updateProgress(
                        Math.round((i / sortedImages.length) * 80),
                        `Processing image ${i + 1} of ${sortedImages.length}...`
                    );

                    // Convert image to PNG blob
                    const canvas = document.createElement('canvas');
                    canvas.width = originalImg.width;
                    canvas.height = originalImg.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(originalImg, 0, 0);

                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    imgFolder.file(filename, blob);

                    // Store image state
                    projectData.images.push({
                        filename: filename,
                        x: img.x(),
                        y: img.y(),
                        scaleX: img.scaleX(),
                        scaleY: img.scaleY(),
                        rotation: img.rotation(),
                        cropBounds: img.getAttr('cropBounds') || { top: 0, right: 0, bottom: 0, left: 0 },
                        blendMode: img.getAttr('blendMode') || 'source-over',
                        originalWidth: img.getAttr('originalWidth'),
                        originalHeight: img.getAttr('originalHeight'),
                        name: img.name()
                    });
                }

                // Add project.json
                zip.file('project.json', JSON.stringify(projectData, null, 2));

                updateProgress(90, 'Creating archive...');

                // Generate zip file
                const content = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                }, (metadata) => {
                    updateProgress(90 + Math.round(metadata.percent * 0.1), 'Creating archive...');
                });

                updateProgress(100, 'Done!');

                // Download
                const link = document.createElement('a');
                link.download = 'project.montage';
                link.href = URL.createObjectURL(content);
                link.click();
                URL.revokeObjectURL(link.href);

                setTimeout(hideProgressModal, 500);

            } catch (err) {
                hideProgressModal();
                console.error('Error saving project:', err);
                alert('Failed to save project: ' + err.message);
            }
        }

        // Load project from .montage file
        async function loadProject(file) {
            showProgressModal('Adding from Project...');

            try {
                updateProgress(10, 'Reading archive...');

                const zip = await JSZip.loadAsync(file);
                const projectFile = zip.file('project.json');

                if (!projectFile) {
                    throw new Error('Invalid .montage file: missing project.json');
                }

                const projectData = JSON.parse(await projectFile.async('string'));

                updateProgress(20, 'Loading images...');

                // Calculate offset to center loaded images in current viewport
                // First, find the bounding box center of the saved images
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const imgData of projectData.images) {
                    minX = Math.min(minX, imgData.x);
                    minY = Math.min(minY, imgData.y);
                    maxX = Math.max(maxX, imgData.x);
                    maxY = Math.max(maxY, imgData.y);
                }
                const savedCenterX = (minX + maxX) / 2;
                const savedCenterY = (minY + maxY) / 2;

                // Calculate viewport center in stage coordinates
                const viewportCenterX = (stage.width() / 2 - stage.x()) / stage.scaleX();
                const viewportCenterY = (stage.height() / 2 - stage.y()) / stage.scaleY();

                // Offset to apply to each loaded image
                const offsetX = viewportCenterX - savedCenterX;
                const offsetY = viewportCenterY - savedCenterY;

                // Load images (additive - keeps existing images)
                const imgFolder = zip.folder('images');
                const totalImages = projectData.images.length;

                for (let i = 0; i < totalImages; i++) {
                    const imgData = projectData.images[i];

                    updateProgress(
                        20 + Math.round((i / totalImages) * 75),
                        `Loading image ${i + 1} of ${totalImages}...`
                    );

                    const imgFile = imgFolder.file(imgData.filename);
                    if (!imgFile) {
                        console.warn(`Missing image: ${imgData.filename}`);
                        continue;
                    }

                    const imgBlob = await imgFile.async('blob');
                    const imgUrl = URL.createObjectURL(imgBlob);

                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            const konvaImage = new Konva.Image({
                                image: img,
                                x: imgData.x + offsetX,
                                y: imgData.y + offsetY,
                                scaleX: imgData.scaleX,
                                scaleY: imgData.scaleY,
                                rotation: imgData.rotation,
                                draggable: true,
                                name: imgData.name || `image-${i}`
                            });

                            // Set original dimensions
                            konvaImage.setAttr('originalImage', img);
                            konvaImage.setAttr('originalWidth', imgData.originalWidth || img.width);
                            konvaImage.setAttr('originalHeight', imgData.originalHeight || img.height);

                            // Apply crop bounds
                            const cropBounds = imgData.cropBounds || { top: 0, right: 0, bottom: 0, left: 0 };
                            konvaImage.setAttr('cropBounds', cropBounds);

                            const originalWidth = imgData.originalWidth || img.width;
                            const originalHeight = imgData.originalHeight || img.height;
                            const cropX = cropBounds.left;
                            const cropY = cropBounds.top;
                            const cropWidth = originalWidth - cropBounds.left - cropBounds.right;
                            const cropHeight = originalHeight - cropBounds.top - cropBounds.bottom;

                            if (cropWidth > 0 && cropHeight > 0) {
                                konvaImage.crop({ x: cropX, y: cropY, width: cropWidth, height: cropHeight });
                                konvaImage.width(cropWidth);
                                konvaImage.height(cropHeight);
                                konvaImage.offsetX(cropWidth / 2);
                                konvaImage.offsetY(cropHeight / 2);
                            } else {
                                konvaImage.offsetX(img.width / 2);
                                konvaImage.offsetY(img.height / 2);
                            }

                            // Apply blend mode
                            const blendMode = imgData.blendMode || 'source-over';
                            konvaImage.setAttr('blendMode', blendMode);
                            konvaImage.globalCompositeOperation(blendMode);

                            // Set up event handlers
                            konvaImage.on('click tap', (e) => {
                                e.cancelBubble = true;
                                transformer.nodes([konvaImage]);
                                updateCropHandles();
                                imageLayer.batchDraw();
                            });

                            konvaImage.on('dblclick dbltap', () => {
                                konvaImage.moveToTop();
                                transformer.moveToTop();
                                updateCropHandles();
                                imageLayer.batchDraw();
                            });

                            konvaImage.on('contextmenu', (e) => {
                                e.evt.preventDefault();
                                e.cancelBubble = true;
                                transformer.nodes([konvaImage]);
                                updateCropHandles();
                                showContextMenu(e.evt.clientX, e.evt.clientY, konvaImage);
                                imageLayer.batchDraw();
                            });

                            konvaImage.on('dragmove', () => {
                                updateCropHandles();
                            });

                            imageLayer.add(konvaImage);
                            URL.revokeObjectURL(imgUrl);
                            resolve();
                        };
                        img.onerror = () => {
                            URL.revokeObjectURL(imgUrl);
                            reject(new Error(`Failed to load image: ${imgData.filename}`));
                        };
                        img.src = imgUrl;
                    });
                }

                transformer.moveToTop();
                imageLayer.batchDraw();
                updateDropZoneVisibility();
                imageCount += totalImages;

                updateProgress(100, 'Done!');
                setTimeout(hideProgressModal, 500);

            } catch (err) {
                hideProgressModal();
                console.error('Error loading project:', err);
                alert('Failed to load project: ' + err.message);
            }
        }

        document.getElementById('save-project-btn').addEventListener('click', saveProject);

        // Drag and drop
        wrapper.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });

        wrapper.addEventListener('dragleave', (e) => {
            if (!wrapper.contains(e.relatedTarget)) {
                dropZone.classList.remove('active');
            }
        });

        wrapper.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            handleFiles(e.dataTransfer.files);
        });

        // Resize handling
        window.addEventListener('resize', () => {
            stage.width(wrapper.clientWidth);
            stage.height(wrapper.clientHeight);
            stage.batchDraw();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+S saves project, S exports JPG
            if ((e.key === 's' || e.key === 'S') && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                saveProject();
                return;
            }
            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                exportCanvas();
                return;
            }

            const selected = transformer.nodes();
            if (selected.length === 0) return;

            const node = selected[0];
            const moveAmount = e.shiftKey ? 10 : 1;

            switch (e.key) {
                case 'ArrowLeft':
                    node.x(node.x() - moveAmount);
                    updateCropHandles();
                    break;
                case 'ArrowRight':
                    node.x(node.x() + moveAmount);
                    updateCropHandles();
                    break;
                case 'ArrowUp':
                    node.y(node.y() - moveAmount);
                    updateCropHandles();
                    break;
                case 'ArrowDown':
                    node.y(node.y() + moveAmount);
                    updateCropHandles();
                    break;
                case 'Delete':
                case 'Backspace':
                    node.destroy();
                    transformer.nodes([]);
                    removeCropHandles();
                    updateDropZoneVisibility();
                    break;
                case 'h':
                case 'H':
                    flipHorizontal();
                    break;
                case 'v':
                case 'V':
                    flipVertical();
                    break;
                case 'l':
                case 'L':
                    rotateLeft();
                    break;
                case 'r':
                case 'R':
                    rotateRight();
                    break;
                case 'd':
                case 'D':
                    duplicateImage();
                    break;
                case 't':
                case 'T':
                    bringToTop();
                    break;
                case 'g':
                case 'G':
                    sendToBottom();
                    break;
                case 'b':
                case 'B':
                    cycleBlendMode();
                    break;
                default:
                    return;
            }
            e.preventDefault();
            imageLayer.batchDraw();
        });
    </script>
</body>
</html>
